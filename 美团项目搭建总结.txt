----------------------项目总结--------------------------
1.根据需求建表
根据需求建立模型，在数据库事先建好最终的结果表，再由上往下推导出所需的表和字段。

2.将整理好的表分为两类，A类是实时更新的桶表，B类是储存历史数据的分区表，实时更新的表使用全量导入、历史数据的表采用增量导入的方式导入ods层

在本项目中的A类表有：
ods_code_category
ods_user
ods_user_extend
ods_user_addr

B类表有：
ods_us_order
ods_cart
ods_order_delivery
ods_order_item
ods_user_app_click_log
ods_user_pc_click_log
 -为了方便起见，可以将ods层和dwd层设为外部表，指定好目录，导入时使用删除目录再创建的方式进行全量导入，使用传参方式进行分区导入（或指定目录覆盖导入），用上传数据到hdfs的方式代替hive的连接

3.dwd层有两个可选事务：

 -桶表的更新：如果业务中有需求某个数据的变化规律，则建立桶表每日从ods中将该数据导入，进行SCD2策略的更新操作，否则不建表;
 
 -分区表的新增：如果ods层是用覆盖导入的方式导入历史数据，则dwd层应该建立分区表将当日的历史数据导入到分区中，否则不建表

4.dws层负责存储最终结果表的常用中间表
在本项目中，存储的是用户宽表以及用户月访问记录表，B类表需要分区存储，A类表则使用覆盖创建的方式生成

5.dm层存储业务需求的最终结果表，需要分区，每日执行。
    -数据源从ods层、dwd层、dws层中拿取都可以
    -可以考虑追加一个字段import-dt，保存统计的日期

6.将dm层的结果导出到数据库，如果前面追加了import-dt字段，则导出操作只需要传递参数指定导出目录即可直接导入到数据库。（由import-dt字段来区分执行维度）

7.每日的执行流程为db->ods->dwd->dws->dm->db

注：所有的分区插入方式推荐为overwrite

-----------------------项目改进-------------------------
1.增加通用性：通过flow2.0传递全局变量，可以做到：不传变量时默认执行统计昨天的数据，传递变量时则统计变量日期。
  - 为了达到这个目的，分区插入的方式必须为overwrite;
  - sql语句中的检索逻辑不使用分区字段，将分区字段从sql逻辑中分离出来仅作为参考使用。
  
2.日期处理：变量传递到sql中时，先在外部将日期格式转为时间戳传入，在sql内部用from_unixtime再转化为日期格式。
原因：外部传递的参数在sql内部无法被识别为字符串格式，就算使用cast转换也无法读取'-'这个特殊符号，因此在外部用
	dt0=`date -d "1 days ago" "+%s"`将昨天的日期转为时间戳传入后再用
	dt=from_unixtime(dt0,'yyyy-MM-dd')的方式获取到昨天的日期格式

3.空值处理：在sql语句中，使用sum（case when）的组合方式来统计数据时，不符合条件的数据应赋予0值
在dm层中，非字符串字段在最终计算结果时，用colease()函数来指定默认值。
建表时指定空值保存字符串为""

-----------------------尚未实现-------------------------
1.如果客户有查询历史数据的需求的话，hbase很适合作为SCD2策略的存储方式
2.连续登陆模块
3.购物篮组合模块
4.地图模块